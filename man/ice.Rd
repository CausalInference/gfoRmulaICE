% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ICE.R
\name{ice}
\alias{ice}
\title{Iterative Conditional Expectation Estimator}
\usage{
ice(
  data,
  time_points,
  id,
  time_name,
  outcome_name,
  censor_name = NULL,
  compevent_name = NULL,
  comp_effect = 0,
  outcome_model,
  censor_model = NULL,
  competing_model = NULL,
  hazard_model = NULL,
  global_hazard = F,
  ref_idx = 0,
  estimator,
  int_descript,
  ci_method = "percentile",
  nsamples = 0,
  seed = 1,
  coverage = 95,
  parallel = F,
  ncores = 2,
  ...
)
}
\arguments{
\item{data}{a data frame containing the observed data in long format.}

\item{time_points}{a number indicating the total number of time points.}

\item{id}{a string indicating the ID variable name in \code{data}.}

\item{time_name}{a string specifying the time variable name in \code{data}.}

\item{outcome_name}{a string specifying the outcome variable name in \code{data}.}

\item{censor_name}{a string specifying the censor variable name in \code{data}. Default is \code{NULL}.}

\item{compevent_name}{a string specifying the competing variable name in \code{data}. Default is \code{NULL}.}

\item{comp_effect}{a number indicating how the competing event is handled for all the specified interventions. Default is 0.
0 for controlled direct effect. 1 for total effect.}

\item{outcome_model}{a formula specifying the model statement for the outcome.}

\item{censor_model}{a formula specifying the model statement for the censoring event. Default is \code{NULL}.}

\item{competing_model}{a formula specifying the model statement for the competing event. Default is \code{NULL}.}

\item{hazard_model}{a formula specifying the model statement for the hazard, if hazard-based estimator is used. Default is \code{NULL}. 
If specified, the model in \code{hazard_model} will be used. If NULL, the model in \code{outcome_model} will be used.}

\item{global_hazard}{a logical value indicating whether to use global pooled-over-time hazard model or time-specific hazard models, for hazard-based pooled ICE only. 
If \code{TRUE}, use pooled-over-time hazard model. If \code{FALSE}, use time-specific hazard models. Default is \code{FALSE}.}

\item{ref_idx}{a number indicating which intervention to be used as the reference to calculate the risk ratio and risk difference. Default is 0.
0 refers to the natural course as the reference intervention.
Any other numbers refer to the corresponding intervention that users specify in the keyword arguments.}

\item{estimator}{a function specifying which ICE estimator to use for the estimation. Possible inputs are:
\itemize{
\item{Classical pooling over treatment history ICE estimator (classical pooled ICE): }{ \code{pool(hazard = F)}}
\item{Hazard-Based pooling over treatment history ICE estimator (hazard-based pooled ICE): }{ \code{pool(hazard = T)}}
\item{Classical stratifying on treatment history ICE estimator (classical stratified ICE): }{ \code{strat(hazard = F)}}
\item{Hazard-Based stratifying on treatment history ICE estimator (hazard-based stratified ICE): }{ \code{strat(hazard = T)}}
\item{Doubly robust weighted ICE estimator (doubly robust ICE): }{\cr
\code{weight(treat_model)}
where \code{treat_model} is a list specifying the treatment model.}
}}

\item{int_descript}{a vector of strings containing descriptions for each specified intervention.}

\item{ci_method}{a string specifying the method for calculating the confidence interval, if \code{nsamples} is larger than 0.
Possible values are "percentile" and "normal." Default is "percentile."}

\item{nsamples}{a number larger than 0 indicating the number of bootstrap samples. Default is 0.}

\item{seed}{a number indicating the starting seed for bootstrapping. Default is 1.}

\item{coverage}{a number greater than 0 and less than 100 indicating the coverage of the confidence interval. Default is 95.}

\item{parallel}{a logical value indicating whether to parallelize the bootstrap process. Default is \code{FALSE}.}

\item{ncores}{a number indicating the number of CPU cores to use in parallel computing. Default is 2.}

\item{...}{keyword arguments to specify intervention inputs. If stratified ICE is used, keyword arguments also allow intervention-specific outcome models and competing models. 
\cr 
To specify interventions, please follow the input convention below:
\itemize{
\item{Each intervention is specified using the keyword argument name with \emph{intervention} prefix.}
\item{Use \emph{i} after \emph{intervention} prefix in keyword argument name to represent the ith strategy.}
\item{Use \emph{.} followed with \emph{treatment variable name} after \emph{interventioni} in keyword argument name to represent the treatment name within the ith strategy.}
}
Each input of intervention keyword arguments is a list consisting of a vector of intervened values and an optional vector of time points on which the intervention is applied. 
If the intervention time points are not specified, the intervention is applied to all time points. For example, 
an input considers a simultaneous intervention with always treat on A1 and never treat on A2 at all time points looks like: \cr 
\cr
\code{intervention1.A1 = list(static(1))} \cr
\code{intervention1.A2 = list(static(0))} \cr \cr
The above intervention applies to all time points. The following is an example of custom intervention time points, 
with always treat on A1 at time point 1 and 2 and never treat on A2 at time point 3 to 5. \cr 
\cr
\code{intervention1.A1 = list(static(1), 1:2)} \cr
\code{intervention1.A2 = list(static(0), 3:5)} \cr
\cr If there is no intervention keyword argument specified, the function returns the natural course risk only. Please see the "Examples" section for more examples.

To specify different outcome model and/or competing model for different intervention, please follow the input convention below:

\itemize{
\item{Each outcome model is specified using keyword argument name starting with \emph{outcomeModel} or \emph{compModel} prefix for outcome model or competing model correspondingly.}
\item{Use \emph{.n} after \emph{outcomeModel} or \emph{compModel} prefix in keyword argument name to specify which intervention being applied to,
where \emph{n} represents the \emph{n}th intervention.}
}

The input to each outcome or competing model keyword argument is a model statement formula. 
If no outcome model and competing model keyword argument is specified, the models specified in \code{outcome_model} and \code{comp_model} are used.
Please refer to the "Examples" section for more examples.}
}
\value{
A list containing the following components. Each component that contains the fitted models includes the model fits, the summary of the fitted model, 
standard errors of the coefficients, variance-covariance matrices of the parameters, and the root mean square error (RMSE) values.
\item{estimator.type}{A string describing the type of the estimator.}
\item{summary}{A summary table containing the estimated risk, risk ratio, and risk difference for user-defined interventions including estimated natural course risk and the observed risk.
If \code{nsamples} is greater than 0, the summary table includes standard error and confidence interval for the point estimates.}
\item{risk.over.time}{A data frame containing the estimated risk at each time point for each intervention.}
\item{initial.outcome}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the outcome model in the first step of algorithm.}
\item{initial.comp}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the competing model in the first step of algorithm (if applicable).}
\item{np.risk.model}{A list containing the fitted models for the censoring and/or competing model in estimating observed risk (if applicable).}
\item{outcome.models.by.step}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the outcome model in each iteration of algorithm.}
\item{comp.models.by.step}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the competing model in each iteration of algorithm (if applicable).}
\item{hazard.models.by.step}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the hazard model (if applicable), either time-specific models at all time points or one pooled-over-time global model.} 
\item{boot.data}{A list of bootstrap samples. If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
\item{boot.initial.outcome}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the outcome model in the first step of algorithm on the bootstrap samples.
If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
\item{boot.initial.comp}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the competing model in the first step of algorithm on the bootstrap samples (if applicable).
If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
\item{boot.np.risk.model}{A list containing the fitted models for the censoring and/or competing model in estimating observed risk on the bootstrap samples (if applicable).
If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
\item{boot.outcome.models.by.step}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the outcome model in each iteration of algorithm on the bootstrap samples (if applicable).
If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
\item{boot.comp.models.by.step}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the competing model in each iteration of algorithm on the bootstrap samples (if applicable).
If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
\item{boot.hazard.models.by.step}{A list, where the name of each sublist corresponds to each specified intervention description, and each sublist contains the fitted models for the hazard model (if applicable), either time-specific models at all time points or one pooled-over-time global model, on the bootstrap samples.
If \code{nsamples} is set to 0, a \code{NULL} value is returned.}
}
\description{
This function implements iterative conditional expectation (ICE) estimators under user-defined treatment strategies.
Available ICE estimators are classical and hazard-based pooling over treatment history ICE, 
classical and hazard-based stratifying on treatment history ICE, and doubly robust ICE estimators. 
See Wen et al. (2021) for more details regarding the parametric g-formula iterative conditional expectation estimator.
}
\details{

}
\examples{

data <- gfoRmulaICE::compData

# Example 1: Dynamic Intervention

# We consider the following interventions and intervened at all time points.
# Intervention 1 on A2: at time t, if L1 = 0, then treat; otherwise, not treat. 
# Intervention 2 on A2: never treat upon until L1 = 0, after which follows always treat.
# Intervention 3 on A2: never treat upon until L1 = 0, after which follows natural course.

# We use classical pooled ICE estimator, 
# natural course as the reference intervention, and the following models:
# a. outcome model: Y ~ L1 + L2 + A1 + A2
# b. censor model: C ~ L1 + L2 + A1 + A2
# c. competing model: D ~ L1 + L2 + A1 + A2.
# We estimate variance using bootstrap with 1000 replicates, normal quantile, and parallel computing.

ice_fit1 <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2 + A1 + A2, 
censor_model = C ~ L1 + L2 + A1 + A2,
ref_idx = 0,
estimator = pool(hazard = F),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Dynamic Intervention 1", "Dynamic Intervention 2", 
"Dynamic Intervention 3"),
intervention1.A2 = list(dynamic("L1 == 0", static(0), static(1))),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1), absorb = T)),
intervention3.A2 = list(dynamic("L1 == 0", static(0), natural_course()))
)

plot_risk(ice_fit1)

# Example 2: Built-in Interventions

# We consider the following interventions and intervene at all time points.
# Intervention 1 on A1: always treat with value 3.
# Intervention 1 on A2: always treat with value 1.
# Intervention 2 on L2: when the natural value of L2 at time t is lower than -3, set its value to -3. 
# Otherwise, do not intervene.
# Intervention 3 on A2: dynamic intervention (treat when L1 = 0) with uniform grace period of 2 periods

# We use classical pooled ICE estimator, 
# natural course as the reference intervention, and the following models:
# a. outcome model: Y ~ L1 + L2 + A1 + A2
# b. censor model: C ~ L1 + L2 + A1 + A2
# c. competing model: D ~ L1 + L2 + A1 + A2.
# We estimate variance using bootstrap with 1000 replicates, normal quantile, and parallel computing.

ice_fit2 <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2 + A1 + A2, 
censor_model = C ~ L1 + L2 + A1 + A2,
ref_idx = 0,
estimator = pool(hazard = F),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Threshold Intervention", 
"Dynamic Intervention with Grace Period"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.L2 = list(threshold(-3, Inf)),
intervention3.A2 = list(grace_period("uniform", 2, "L1 == 0"))
)

plot_risk(ice_fit2)

# Example 3: User-defined Intervention

# We consider the following interventions and intervene at all time points.
# Intervention 1 on A1: always treat with value 3.
# Intervention 1 on A2: always treat with value 1.
# Intervention 2 on A1: at time t, if L2 < 0, then assign 1; if 0 <= L2 < 2, then assign 2; otherwise, assign 3.
# Intervention 2 on A2: at time t, if L1 = 0, then treat; otherwise, not treat. 

# We use classical pooled ICE estimator, 
# natural course as the reference intervention, and the following models:
# a. outcome model: Y ~ L1 + L2 + A1 + A2
# b. censor model: C ~ L1 + L2 + A1 + A2
# c. competing model: D ~ L1 + L2 + A1 + A2.
# We estimate variance using bootstrap with 1000 replicates and percentile quantile.

dynamic_cat <- case_when(data$L2 < 0 ~ 1,
data$L2 >= 0 & data$L2 < 2 ~ 2, T ~ 3)

ice_fit3 <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2 + A1 + A2, 
censor_model = C ~ L1 + L2 + A1 + A2,
ref_idx = 0,
estimator = pool(hazard = F),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit3)

# Example 4: Different ICE Estimators

# We use the interventions in Example 3 and implement each ICE estimator.

# a. hazard-based pooled ICE:
# hazard model is time-specific and shares the same model statement as the outcome model

ice_fit4a <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2 + A1 + A2, 
censor_model = C ~ L1 + L2 + A1 + A2,
competing_model = D ~ L1 + L2 + A1 + A2,
ref_idx = 0,
estimator = pool(hazard = T),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit4a)

# b. hazard-based pooled ICE: 
# hazard model is time-specific and uses Y ~ L1 + L2

ice_fit4b <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2 + A1 + A2, 
censor_model = C ~ L1 + L2 + A1 + A2,
competing_model = D ~ L1 + L2 + A1 + A2,
hazard_model = Y ~ L1 + L2,
ref_idx = 0,
estimator = pool(hazard = T),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit4b)

# c. hazard-based pooled ICE: 
# hazard model is pooled-over-time and includes flexible terms of time variable

library(splines)

ice_fit4c <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2 + A1 + A2, 
censor_model = C ~ L1 + L2 + A1 + A2,
competing_model = D ~ L1 + L2 + A1 + A2,
hazard_model = Y ~ L1 + L2 + A1 + A2 + ns(t0, df = 2),
global_hazard = T,
ref_idx = 0,
estimator = pool(hazard = T),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit4c)

# d. classical stratified ICE:

ice_fit4d <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2, 
censor_model = C ~ L1 + L2,
ref_idx = 0,
estimator = strat(hazard = F),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit4d)

# e. hazard-based stratified ICE:
# hazard model is time-specific and uses Y ~ L1 
# (Note: a pooled-over-time hazard model is not valid for stratified ICE.)

ice_fit4e <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2, 
censor_model = C ~ L1 + L2,
competing_model = D ~ L1 + L2,
hazard_model = Y ~ L1,
ref_idx = 0,
estimator = strat(hazard = T),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention: Model 1", 
"Dynamic Intervention: Model 1"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit4e)


# f. doubly robust ICE:

ice_fit4f <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ L1 + L2, 
censor_model = C ~ L1 + L2,
ref_idx = 0,
estimator = weight(list(A1 ~ L1 + L2, A2 ~ L1 + L2)),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", 
"Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit4f)


# g. hazard-based stratified ICE with intervention-specific models:
# hazard model is time-specific and same as the outcome model
# consider the total effect for competing event,
# using normal quantile for variance estimates,
# and the following outcome models and competing models:
# outcome model for intervention 1: Y ~ L1,
# outcome model for intervention 2: Y ~ L1 + L2,
# competing model for intervention 1: D ~ L1 + L2,
# competing model for intervention 2: D ~ L1

ice_fit4g <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
outcome_model = Y ~ L1, censor_model = C ~ L1,
competing_model = D ~ L1,
comp_effect = 1,
ref_idx = 0,
estimator = strat(hazard = T),
nsamples = 1000, ci_method = "normal",
parallel = T, ncores = 5,
int_descript = c("Static Intervention: Model 2",
"Dynamic Intervention: Model 2"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1))),
outcomeModel.1 = Y ~ L1 + L2,
compModel.2 = D ~ L1 + L2
)

# Compare with the ICE estimates in Example 4e:
plot_risk(ice_fit4e, ice_fit4g)
summary_table(ice_fit4e, ice_fit4g)

# Example 5: Flexible Model Specification

# a. Complicated terms in model statement:
# We use the same interventions and ICE estimator in Example 3, 
# and include polynomial, spline, and lagged terms in models.

ice_fit5a <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ I(L1^2) + rcspline.eval(lag1_L2, knots = 1:3) + A1 + A2,
censor_model = C ~ lag1_L1 + poly(L2, degree = 2) + A1 + A2,
ref_idx = 0,
estimator = pool(hazard = F),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit5a)

# b. Using static intervention as reference:
# We use the same interventions and ICE estimator in Example 3, 
# but use static intervention as the reference intervention.

ice_fit5b <- ice(data = data, time_points = 4, 
id = "id", time_name = "t0",
censor_name = "C", outcome_name = "Y",
compevent_name = "D",
comp_effect = 0,
outcome_model = Y ~ I(L1^2) + rcspline.eval(lag1_L2, knots = 1:3) + A1 + A2,
censor_model = C ~ lag1_L1 + poly(L2, degree = 2) + A1 + A2,
ref_idx = 1,
estimator = pool(hazard = F),
nsamples = 1000, ci_method = "percentile",
parallel = T, ncores = 5,
int_descript = c("Static Intervention", "Dynamic Intervention"),
intervention1.A1 = list(static(3)),
intervention1.A2 = list(static(1)),
intervention2.A1 = list(dynamic_cat),
intervention2.A2 = list(dynamic("L1 == 0", static(0), static(1)))
)

plot_risk(ice_fit5b)


}
\references{
Wen L, Young JG, Robins JM, Hernán MA. Parametric g-formula implementations for causal survival analyses. Biometrics. 2021;77(2):740-753.

McGrath S, Lin V, Zhang Z, Petito LC, Logan RW, Hernán MA, and JG Young. gfoRmula: An R package for estimating the effects of sustained treatment strategies via the parametric g-formula. Patterns. 2020;1:100008.

Young JG, Herńan MA, Robins JM. Identification, estimation and approximation of risk under interventions that depend on the natural value of treatment using observational data. Epidemiologic Methods. 2014;3(1):1-19.

Young JG, Vatsa R, Murray EJ, Hernán MA. Interval-cohort designs and bias in the estimation of per-protocol effects: a simulation study. Trials. 2019;20(1):552.

Díaz, I, Williams, N, Hoffman, KL, & Schenck, EJ. Nonparametric causal effects based on longitudinal modified treatment policies. Journal of the American Statistical Association. 2021;118(542), 846–857.

Young JG, Stensrud MJ, Tchetgen Tchetgen EJ, Hernán MA. A causal framework for classical statistical estimands in failure-time settings with competing events. Statistics in medicine. 2020;39(8):1199-1236.

Wen L, Hernán MA, Robins JM. Multiply robust estimators of causal effects for survival outcomes. Scandinavian journal of statistics, theory and applications. 2022;49(3):1304-1328.

Haneuse S, Rotnitzky A. Estimation of the effect of interventions that modify the received treatment. Statistics in medicine. 2013;32(30):5260-5277.

McGrath S, Young JG, Hernán MA. Revisiting the g-null Paradox. Epidemiology. 2022;33(1):114-120.

Chiu YH, Wen L, McGrath S, Logan R, Dahabreh IJ, Hernán MA. Evaluating model specification when using the parametric g-formula in the presence of censoring. American Journal of Epidemiology. 2023;192:1887–1895.
}
